import java.io.*;
import java.util.*;
public class HYPO {
    //Declaration of Global Variables
    static long MAR, MBR, IR, PSR, clock, SP, PC;
    static long[] RAM, GPR;
    static long opAddress;
    static long opValue;
    static long ProcessID = 1;
    static long PCB_SIZE = 10;//Placeholder for now

    //Declaration of error codes
    static final long OK = 0;
    static final long EndOfList = -1;
    static final long ReadyState = 1;
    static final long DefaultPriority = 128;
    static final long ERROR_FILE_OPEN = -404;
    static final long ERROR_INVALID_ADDRESS = -405;
    static final long ERROR_NO_END_OF_PROGRAM = -1;
    static final long ERROR_INVALID_PC_VALUE = -2;
    static final long ERROR_OP_MODE_VALUE = -3;
    static final long ERROR_GPR_VALUE = -4;
    static final long ERROR_OPERAND_FETCH_FAILED = -5;
    static final long ERROR_DESTINATION_IMMEDIATE_MODE = -6;
    static final long ERROR_FATAL = -100;
    static final long ERROR_RUNTIME = -7;
    static final long ERROR_STACK_OVERFLOW = -8;
    static final long ERROR_STACK_UNDERFLOW = -9;


    /*
    // Function: Main
    //
    // Task Description:
    // 	...
    //
    // Input Parameters
    //	None
    //
    // Output Parameters
    //	None
    //
    // Function Return Value
    //	OK - On successful execution
    //  TODO: Error codes for main
     */

    public static void main(String[] args) throws Exception {
        System.out.println("System initialized\n");
        InitializeSystem();
        InitializePCB(0);

        boolean fileLoaded = true;
        Scanner reader = new Scanner(System.in);
        long returnValue;
        long executionCompletionStatus;

        //FetchOperand(0, 3);

        //DumpMemory("Test message", 20000, 5); //Test to make sure that DumpMemory throws the proper exception

        //DumpMemory("Second Test", 500, 127);
        while(fileLoaded){
            System.out.println("Please insert name of file for execution:");
            returnValue = AbsoluteLoader(reader.nextLine());
            //System.out.println(returnValue);
            if(returnValue >= 0 && returnValue <= 9999){
                fileLoaded = false;
                PC = returnValue;
            }
        }

        DumpMemory("After Loading Program", 0, 99);
        executionCompletionStatus = CPUExecuteProgram();
        DumpMemory("After program execution", 0, 99);

        //return(executionCompletionStatus); //main method cannot have a return type

    }

    /*
    // Function: InitializeSystem
    //
    // Task Description:
    // 	Set all global system hardware components to 0
    //
    // Input Parameters
    //	None
    //
    // Output Parameters
    //	None
    //
    // Function Return Value
    //	None
    */
    static void InitializeSystem(){
        RAM = new long[10000];
        MAR = 0;
        MBR = 0;
        IR = 0;
        GPR = new long[8];
        PSR = 0;
        clock = 0;
        SP = 0;
        PC = 0;
    }

    /*
    // Function: AbsoluteLoader
    //
    // Task Description:
    //      Open the file containing HYPO machine user program
    //      and load the content into memory
    //      On successful load, return the PC value in the End of Program line
    //      On failure, display appropriate error message and return appropriate error type
    //
    // Input Parameters
    //	    filename        Name of the Hypo machine executable file
    //
    // Output Parameters
    //	None
    //
    // Function Return Value
    //	ErrorFileOpen           Unable to open the file
    //  ErrorInvalidAddress     Invalid address error
    //  ErrorNoEndOfProgram     Missing end of program indicator
    //  ErrorInvalidPCValue     invalid PC value
    //  0 to 9999               Successful Load, valid PC value
    */
    static long AbsoluteLoader(String filename){
        try{
            File fileImport = new File(filename);
            Scanner scan = new Scanner(fileImport);
            while(scan.hasNextLine()){
                String data = scan.nextLine();
                String[] imported = data.split(" ");
                int ramLocation = Integer.parseInt(imported[0]);
                long memoryData = Long.parseLong(imported[1]);
                if(ramLocation < -1 || ramLocation > 10000){
                    System.out.println("Error, invalid address");
                    scan.close();
                    return ERROR_INVALID_ADDRESS;
                } else if(ramLocation != -1 && (ramLocation > 0 || ramLocation < 10000)) {
                    RAM[ramLocation] = memoryData;
                } else if(ramLocation == -1 && (memoryData > 9999 || memoryData < 0)){
                    System.out.println("Error, invalid PC value");
                    scan.close();
                    return ERROR_INVALID_PC_VALUE;
                } else {
                    scan.close();
                    return Long.parseLong(imported[1]);
                }
            }
            scan.close();
        } catch (FileNotFoundException e) {
            System.out.println("Error, file not found");
            return ERROR_FILE_OPEN;
        }
        System.out.println("Error, no valid end of program");
        return ERROR_NO_END_OF_PROGRAM;
    }

    /*
    // Function: CPUexecuteProgram
    //
    // Task Description:
    // 	    Takes in instructions that are in memory and executes them
    //
    // Input Parameters
    //	None
    //
    // Output Parameters
    //	None
    //
    // Function Return Value
    //	    OK                                  On successful execution
    //      ERROR_INVALID_PC_VALUE              Invalid PC value
    //      ERROR_GPR_VALUE                     Invalid GPR register
    //      ERROR_FETCH_OPERAND_VALUE           Invalid operand execution
    //      ERROR_DESTINATION_IMMEDIATE_MODE    Cannot assign values to set values
    //      ERROR_FATAL                         Fatal error, cannot divide by zero
    //      ERROR_RUNTIME                       PC outside expected range
    //      ERROR_STACK_OVERFLOW                SP over expected range
    //      ERROR_STACK_UNDERFLOW               SP under expected range
    //
    */
    static long CPUExecuteProgram(){
        long opCode;
        long remainder;
        long op1Mode;
        long op1GPR;
        long op2Mode;
        long op2GPR;
        long status;

        long op1Address;
        long op2Address;
        long op1Value;
        long op2Value;
        long result;

        boolean continueExecution = true;
        while(continueExecution){

            //Fetch Cycle
            // Fetch (read) the first word of the instruction pointed by PC into MBR
            // Instruction needing more words (2 word and 3 word instructions) are fetched
            // based on instruction (opcode)
            // when the operand 1 and operand 2 values are fetched using modes

            if ((0 <= PC) && (PC <= RAM.length)) {
                MAR = PC;
                PC++;
                MBR = RAM[(int) MAR];
            } else {
                System.out.println("Error, PC value outside expected range");
                return ERROR_INVALID_PC_VALUE;
            }

            IR = MBR;
            // Decode cycle
            // Decode the first word of the instruction into opcode,
            // operand 1 mode and operand 1 gpr and operand 2 mode and operand 2 gpr
            // using integer division and modulo operators
            // Five fields in the first word of any instruction is:
            // Opcode, Operand 1 mode, operand 1 GPR, Operand 2 mode, Operand 2 GPR

            opCode = IR / 10000;
            remainder = IR % 10000;

            op1Mode = remainder / 1000;
            remainder = remainder % 1000;

            op1GPR = remainder / 100;
            remainder = remainder % 100;

            op2Mode = remainder / 10;
            op2GPR = remainder % 10;


            if (op1GPR >= 8 || op1GPR < 0) {
                System.out.println("Error, operation 1 GPR out of bounds");
                return ERROR_GPR_VALUE;
            }
            if (op2GPR >= 8 || op2GPR < 0) {
                System.out.println("Error, operation 2 GPR out of bounds");
                return ERROR_GPR_VALUE;
            }

            /*System.out.println("OpCode " + opCode);
            System.out.println("Op1Mode " + op1Mode);
            System.out.println("Op1GPR " + op1GPR);
            System.out.println("Op2Mode " + op2Mode);
            System.out.println("Op2GPR " + op2GPR + "\n");*/

            switch ((int) opCode) {
                case 0: //HALT
                    System.out.println("Halt instruction encountered");
                    continueExecution = false;
                    clock += 12;
                    return OK;
                case 1: //ADD
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    status = fetchOperand(op2Mode, op2GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op2Value = opValue;
                    op2Address = opAddress;

                    result = op1Value + op2Value;

                    if (op1Mode == 1) { //Checks for register mode
                        GPR[(int) op1GPR] = result;
                    } else if (op1Mode == 6) { //Checks for immediate mode
                        //Error, destination cannot be immediate mode
                        System.out.println("Error, Destination operand cannot be immediate value");
                        return ERROR_DESTINATION_IMMEDIATE_MODE;
                    } else {
                        RAM[(int) op1Address] = result;
                    }
                    clock += 3;
                    break;
                case 2: //Subtract
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    status = fetchOperand(op2Mode, op2GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op2Value = opValue;
                    op2Address = opAddress;

                    result = op1Value - op2Value;

                    if (op1Mode == 1) { //Checks for register mode
                        GPR[(int) op1GPR] = result;
                    } else if (op1Mode == 6) { //Checks for immediate mode
                        //Error, destination cannot be immediate mode
                        System.out.println("Error, Destination operand cannot be immediate value");
                        return ERROR_DESTINATION_IMMEDIATE_MODE;
                    } else {
                        RAM[(int) op1Address] = result;
                    }
                    clock += 3;
                    break;
                case 3: //Multiply
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    status = fetchOperand(op2Mode, op2GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op2Value = opValue;
                    op2Address = opAddress;

                    result = op1Value * op2Value;

                    if (op1Mode == 1) { //Checks for register mode
                        GPR[(int) op1GPR] = result;
                    } else if (op1Mode == 6) { //Checks for immediate mode
                        //Error, destination cannot be immediate mode
                        System.out.println("Error, Destination operand cannot be immediate value");
                        return ERROR_DESTINATION_IMMEDIATE_MODE;
                    } else {
                        RAM[(int) op1Address] = result;
                    }
                    clock += 6;
                    break;
                case 4: //Divide
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    status = fetchOperand(op2Mode, op2GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op2Value = opValue;
                    op2Address = opAddress;

                    if (op2Value == 0) {
                        System.out.println("Fatal Error, cannot divide by zero");
                        return ERROR_FATAL;
                        //TODO: Check for fatal errors in main
                    }

                    result = op1Value / op2Value;

                    if (op1Mode == 1) { //Checks for register mode
                        GPR[(int) op1GPR] = result;
                    } else if (op1Mode == 6) { //Checks for immediate mode
                        //Error, destination cannot be immediate mode
                        System.out.println("Error, Destination operand cannot be immediate value");
                        return ERROR_DESTINATION_IMMEDIATE_MODE;
                    } else {
                        RAM[(int) op1Address] = result;
                    }
                    clock += 6;
                    break;
                case 5: //Move
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    status = fetchOperand(op2Mode, op2GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op2Value = opValue;
                    op2Address = opAddress;


                    if (op1Mode == 1) { //Checks for register mode
                        GPR[(int) op1GPR] = op2Value;
                    } else if (op1Mode == 6) { //Checks for immediate mode
                        //Error, destination cannot be immediate mode
                        System.out.println("Error, Destination operand cannot be immediate value");
                        return ERROR_DESTINATION_IMMEDIATE_MODE;
                    } else {
                        RAM[(int) op1Address] = op2Value;
                    }
                    clock += 2;
                    break;
                case 6: //Branch or jump on instruction
                    if (PC < 0 || PC > 9999) {
                        System.out.println("Error, runtime error");
                        return ERROR_RUNTIME;
                    } else {
                        PC = RAM[(int) PC];
                    }
                    clock += 2;
                    break;
                case 7: //Branch on minus
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op1Value = opValue;
                    op1Address = opAddress;

                    if (op1Value < 0) {
                        if (PC < 0 || PC > 9999) {
                            System.out.println("Error, runtime error");
                            return ERROR_RUNTIME;
                        } else {
                            PC = RAM[(int) PC];
                        }
                    } else {
                        PC++;
                    }
                    clock += 4;
                    break;
                case 8: //Branch on plus
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op1Value = opValue;
                    op1Address = opAddress;

                    if (op1Value > 0) {
                        if (PC < 0 || PC > 9999) {
                            System.out.println("Error, runtime error");
                            return ERROR_RUNTIME;
                        } else {
                            PC = RAM[(int) PC];
                        }
                    } else {
                        PC++;
                    }
                    clock += 4;
                    break;
                case 9: //Branch on zero
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }

                    op1Value = opValue;
                    op1Address = opAddress;

                    if (op1Value == 0) {
                        if (PC < 0 || PC > 9999) {
                            System.out.println("Error, runtime error");
                            return ERROR_RUNTIME;
                        } else {
                            PC = RAM[(int) PC];
                        }
                    } else {
                        PC++;
                    }
                    clock += 4;
                    break;
                case 10: //Push - if stack is not full
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    if (SP < 0 || SP > 9999) {
                        System.out.println("Error, stack overflow");
                        return ERROR_STACK_OVERFLOW;
                    }

                    SP++;
                    RAM[(int) SP] = op1Value;
                    clock += 2;
                    break;
                case 11: //Pop - if stack not empty
                    if (SP < 0 || SP > 9999) {
                        System.out.println("Error, stack underflow");
                        return ERROR_STACK_UNDERFLOW;
                    }
                    status = fetchOperand(op1Mode, op1GPR);
                    if (status != OK) {
                        System.out.println("Error, system cannot fetch operand");
                        return ERROR_OPERAND_FETCH_FAILED;
                    }
                    op1Value = opValue;
                    op1Address = opAddress;

                    RAM[(int) op1Address] = RAM[(int) SP];

                    SP--;
                    clock += 2;
                    break;
                case 12: //System call
                    //TODO: Figure out what system call is
                    clock += 12;
                    break;
                default:
                    System.out.println("Error, opCode outside expected parameters");

            }
        }

        return OK;

    }

    /*
    // Function: FetchOperand
    //
    // Task Description:
    // 	...
    //
    // Input Parameters
    //      OpMode      Operand mode value
    //      OpReg       Operand GPR value
    //
    // Output Parameters
    //      OpAddress   Address of operand
    //      OpValue     Operand value when mode and GPR are valid
    //
    // Function Return Value
    //      OK                      On successful fetch
    //      ErrorInvalidPC          PC value outside expected range
    //      ErrorInvalidAddress     Address outside expected range
    //      ErrorInvalidOpMode      OpMode outside expected range
    */
    static long fetchOperand(long opMode, long opReg){
        //Fetch operand based on the operand mode
        switch((int) opMode){
            case 1:
                opAddress = -1;
                opValue = GPR[(int) opReg];
                break;
            case 2:
                opAddress = GPR[(int) opReg];
                if(opAddress < 0 || opAddress >= 10000){
                    System.out.println("Error, address outside expected range");
                    return ERROR_INVALID_ADDRESS;
                } else {
                    opValue = RAM[(int) opAddress];
                }
                break;
            case 3:
                opAddress = GPR[(int) opReg];
                if(opAddress < 0 || opAddress >= 10000){
                    System.out.println("Error, address outside expected range");
                    return ERROR_INVALID_ADDRESS;
                } else {
                    opValue = RAM[(int) opAddress];
                }
                GPR[(int) opReg]++;
                break;
            case 4:
                GPR[(int) opReg]--;
                opAddress = GPR[(int) opReg];
                if(opAddress < 0 || opAddress >= 10000){
                    System.out.println("Error, address outside expected range");
                    return ERROR_INVALID_ADDRESS;
                } else {
                    opValue = RAM[(int) opAddress];
                }
                break;
            case 5:
                if(PC < 0 || PC > 9999){
                    System.out.println("Error, PC value outside expected range");
                    return ERROR_INVALID_PC_VALUE;
                }
                opAddress = RAM[(int) PC];
                PC++;
                if(opAddress < 0 || opAddress >= 10000){
                    System.out.println("Error, address outside expected range");
                    return ERROR_INVALID_ADDRESS;
                } else {
                    opValue = RAM[(int) opAddress];
                }
                break;
            case 6:
                if(PC < 0 || PC > 9999){
                    System.out.println("Error, PC value outside expected range");
                    return ERROR_INVALID_PC_VALUE;
                }
                opAddress = -1;
                opValue = RAM[(int) PC];
                PC++;
                break;
            default:
                System.out.println("Error, opMode outside expected parameters");
                return ERROR_OP_MODE_VALUE;
        }
        return OK;
    }

    /*
    // Function: DumpMemory
    //
    // Task Description:
    // 	    Displays a string passed as one of the input parameter
    //      Displays the content of GPRs, SP, PC, PSR, system clock, and
    //      the content of specified memory locations in a specific format
    //
    // Input Parameters
    //      Message         String to be displayed
    //      StartAddress    Start address of memory location
    //      Size            Number of locations to dump
    //
    // Output Parameters
    //	None
    //
    // Function Return Value
    //	None
    */
    static void DumpMemory(String message, long startAddress, long size) throws Exception {
        long currentAddress = startAddress;
        long endAddress = startAddress + size;
        //Displays message
        System.out.println(message);

        //Statement to catch if user tries to dump outside expected memory
        if((startAddress + size) > RAM.length){
            System.out.println("Error. memory dump outside expected memory");
            return;
        }

        //Displays GPRs
        System.out.print("GPRs:\t\tG0\tG1\tG2\tG3\tG4\tG5\tG6\tG7\tSP\tPC\n\t\t"
                + GPR[0] + "\t" + GPR[1] + "\t" + GPR[2] + "\t" + GPR[3] + "\t" + GPR[4] + "\t" + GPR[5] + "\t" + GPR[6] + "\t" + GPR[7] + "\t" + SP + "\t" + PC + "\n");

        //Display memory addresses
        System.out.print("Address:\t+0\t+1\t+2\t+3\t+4\t+5\t+6\t+7\t+8\t+9\n");
        while(currentAddress < endAddress){
            System.out.print(currentAddress + "\t\t");
            for(int a = 0; a < 10; a++){
                if(currentAddress < endAddress){
                    System.out.print(RAM[(int) currentAddress] + "\t");
                    currentAddress++;
                } else {
                    break;
                }
            }
            System.out.println();

        }
        System.out.println("Clock: " + clock + "\nPSR: " + PSR);
    }
    static long CreateProcess(){
        return OK;
    }

    static void InitializePCB(long PCBptr) {
    
    for (int i = 0; i < PCB_SIZE; i++) {
        RAM[(int) (PCBptr + i)] = 0; 
    }

    RAM[(int) PCBptr] = ProcessID++;

    RAM[(int) PCBptr + 1] = DefaultPriority;

    RAM[(int) PCBptr + 2] = ReadyState;
    
    RAM[(int) PCBptr + 3] = EndOfList; 
    }

    static void PrintPCB(long PCBptr) {
        System.out.print("PCB address = " + PCBptr + ", ");
        System.out.print("Next PCB Ptr = " + RAM[(int) PCBptr + 3] + ", ");
        System.out.print("PID = " + RAM[(int) PCBptr] + ", ");
        System.out.print("State = " + RAM[(int) PCBptr + 2] + ", ");
        System.out.print("PC = " + RAM[(int) PCBptr + 4] + ", ");
        System.out.print("SP = " + RAM[(int) PCBptr + 5] + ", ");
        System.out.print("Priority = " + RAM[(int) PCBptr + 1] + ", ");
        System.out.println("Stack info: start address = " + RAM[(int) PCBptr + 6] + ", size = " + RAM[(int) PCBptr + 7]);
        System.out.print("GPRs = ");
        for (int i = 0; i < 8; i++) {
            System.out.print("GPR" + i + " = " + GPR[i] + " ");
        }
        System.out.println();
    }

    static long PrintQueue(long Qptr) {
        long currentPCBPtr = Qptr;

        if (currentPCBPtr == EndOfList) {
            System.out.println("Empty list");
            return OK;
        }

        while (currentPCBPtr != EndOfList) {
            PrintPCB(currentPCBPtr);
            currentPCBPtr = RAM[(int) currentPCBPtr + 3];
        }

        return OK;
    }
}
